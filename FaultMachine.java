public class FaultMachine {
    /*
        两个机器存储ID，保证备份，问：
        1）能否快速找到某个表中只出现一次的ID
        2）两台机器死机，假设不会是同一数据
        idea 1:
        遍历列表，记录每个ID出现次数，次数少于2的即为想要的结果
        时间复杂度O(N)，空间复杂度需要存储ID，会动辄几GB
        idea 2:
        采用哈希表记录每个ID出现的次数，若次数为2，则删除该ID
        最好情况下是加一个删一个O(1),最坏是O(N)
        idea 3:
        时间复杂度已经为线性的，很难再去减少，考虑空间复杂度，不去遍历列表
        考虑异或操作，因为X xor X = 0，且X xor 0 = X，将所有列表异或得到一个变量
        则该变量为我们需要的结果，时间复杂度O(N)，空间复杂度O(1)
        考虑第二问有两个ID仅出现一次，所有异或得到的是A xor B，无法确定A和B
        分类讨论：
        1、若A xor B = 0，A=B，(所有ID和-工作ID和)/2 即为所求
        2、若A xor B != 0，则必有某一位为1，ze该位置A和B一个为1一个为0，
           按照该位置将ID分为两类，，分别对两类ID求异或和，即得到A和B结果
        idea 4:
        上述idea 3空间复杂度O(1)，时间复杂度O(N)，复杂度已达到最优，不过第二问
        只能解决两台故障机器ID不同情况，相同的话需要求和做差
        第一问求和做差，得到的就是死机机器ID，时间复杂度O(N)，空间复杂度O(1)
        第二问同样方法可以得到A + B，还需要知道A与B的关系，同样的想法可以得到乘积做除
        就可以得到A * B，解二元一次方程即可，时间复杂度O(N)，空间复杂度O(1)
        但是考虑到ID比较大，乘法的话结果可能会溢出，可以采用平方和取代A^2+B^2
        extension:
        1）若每个机器有三个备份，有同一ID机器有三个，同时三台机器死机，也可采用idea 4么？
          若为N个备份，N台机器死机呢？
        ans：
          等价于解三个三元三次方程组，
          A + B + C = x
          A * B * C = y
          A^2 + B^2 + C^2 = z --> A*B + B*C + A*C = (x^2 - z)/2
          因为(x-a)(x-b)(x-c)=x^3-(a+b+c)x^2+(ab+bc+ac)x-abc，带入该式为0求解
          N元的也是类似
        2）相关问题，从一副扑克牌（抽取大小王）中挑出一张，最简单办法找到挑出的是哪一张（不要求花色）
     */
}
