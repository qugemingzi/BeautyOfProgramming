public class NIM_2 {
    /*
        “拈”游戏
        有 M 块石头和两个玩家 A 和 B，A 先将石头分成若干堆，然后按照 BABA...的顺序轮流
        抽取石头，能将剩下的石头一次取光的玩家获胜。每次取石头时，每个玩家只能从若干堆
        石头中任选一堆，取这一堆石头中任意数目(大于0)个石头。
        请问：玩家A怎样分配和取石头能保证自己有把握取胜？
        analysis:
        我们用 N 表示石头堆数，M 表示总石头数。
        1）N = 1
            只有一堆石头，无论 A 放多少块石头，B 都可以一次性拿完，A 败。
        2）N = 2
            即只有两堆石头，最简单的情况为每堆都只有一个石头(1, 1)，B 先拿，无论怎样 A
            都可以获胜。定义这种在双方理论走法下，A 一定能赢的局面为 “安全局面”。
            M > 2时，考虑(1, 1)为安全局面，那么(1, X)都不是安全局面，因为 B 可以通过
            一步将(1, X)变成(1, 1)。那么(2, 2)呢？它不可以一步变成(1, 1)，除非两步，
            且通过分析知(2, 2)为安全局面，同理(3, 3)...(X, X)都为安全局面。所以我们得到
            初步总结，如果石头总数 M 为偶数，就分为两堆，每堆数目相同，无论 B 怎么取，A
            只需要保证取之后是安全局面(X, X)，则 A 必胜。
        3）M 为奇数呢？
            M = 3，有(2, 1)和(1, 1, 1)两种情况，都是 B 赢。
            M = 5、7...，好像都是 B 赢。
            由此我们又得到一条结论，当摆放方法为(1, 1,..., 1)时，奇数个 1 则 B 赢，偶数
            个 1 则 A 胜。而当摆放方法为(1, 1,..., X)时，B 必赢。因为：
            若奇数个 1，B 只需从(X)堆中取 X-1 个石头；
            若偶数个 1，B 只需从(X)堆中取 X 个石头。
        此时当然还有很多其他的摆法，如何分析呢？关键是找到这一系列变化过程中有没有一个特性
        始终决定着输赢，就得考验一下真功夫了（书里写的），异或(XOR)运算，规则如下：
            XOR(0, 0) = 0
            XOR(0, 1) = 1
            XOR(1, 1) = 0
        统筹来看整个游戏过程，从 N 堆石头(M1, M2,..., Mn)开始斗智斗勇为(0, 0,..., 0)。
        当 M 为偶数时，我们的取胜策略就是将 M 分成相同的两份，这样就可以取胜。
            开始：(M1, M1)         XOR(M1, M1) = 0
            中途：(M1, M2)         XOR(M1, M2) != 0
            A 方：(M2, M2)         XOR(M2, M2) = 0
            ...
            最后：(0, 0)           A 方取胜
        类似的，若 M 为奇数，把石头分为(1, 1,..., 1)奇数堆时，XOR(1, 1,..., 1) != 0，
        此时 B 方取走一堆后，石头堆为偶数堆了，XOR(1, 1,..., 1) = 0，A 败。
        我们推广到 M 为奇数，但每堆石头数目不限于 1 的情况，在观察XOR值的规律。
            开始：(M1, M2,..., Mn)             XOR(M1, M2,..., Mn) = ?
            中途：(M1', M2',..., Mn')          XOR(M1', M2',..., Mn') = ?
            最后：(0, 0,..., 0)                XOR(0, 0,..., 0) = 0
        不幸的是，当有奇数个石头时，无论怎么分堆XOR(M1, M2,..., Mn)总不等于 0，因为必然
        会有奇数堆有奇数个石头（二进制表示最低位为 1），异或的结果最低位为 1。【结论 1】
        再不幸的是，还可以证明，当XOR(M1, M2,..., Mn) != 0时，我们总是只需要改变一个 Mi
        的值，就可以让XOR(M1, M2,..., Mi',..., Mn) = 0。【结论 2】
        更不幸的是，又可以证明，当XOR(M1, M2,..., Mn) = 0时，对任何一个 M 值的改变（取走
        石头），都会让XOR(M1, M2,..., Mi',..., Mn) != 0。【结论 3】
        有了这3个结论，我们不得不承认，当 M 为奇数时，无论怎样分堆，总是先动手的赢，策略
        就是自己取完之后保证总异或值为 0 即可。
        XOR，这个很早就学过的运算，在这里帮了大忙。我们应该对XOR说Orz才对！
        // BoP编者有点皮哈~
        extension:
        1）如果规定相反，取光所有石头的人输，又该如何控制局面？
            (1）N = 1
            B 可以一下取成(1)，B 必赢，(X)不是安全局面，不可以整成一堆。
            (2）N = 2
            (1, 1)、(1, 2)不是安全局面，(2, 2)是安全局面，类比得(X, X)也为安全局面。所以
            M 为偶数时可以采取(M/2, M/2)分堆方法，A 必胜
            (3）N > 2
            M 为奇数时可以采取(1, 1,..., 1)分堆方法，奇数个 1 保证了 A 必胜。
            总结：M = 2时 A 必败，其他情况 A 有必胜策略，其中 M 为奇数时采取(1, 1,..., 1)
            方法；M 为偶数时采取(M/2, M/2)方法。其中 M 为偶数时：
                1、B 取走一整堆为(0, X)，A 取 X-1 个石头为(0, 1)。
                2、B 取走 X-1 个石头为(1, X)，A 取 X 个石头为(0, 1)。
                3、B 取走若干个石头为(Y, X)(Y < X)，A 取相同数目石头为(Y, Y)。
        2）如果每次可以挑选任意 K 堆，并从中任意取石头，又该如何找到必胜策略？
            类似于NIM_1中的extension 2），首先 N > K，否则 B 一下就取完所有石头。A 采取
            平均分配到 K+1 堆是较有胜算的方法。
             M % (K+1) == 0 B 败，无论 B 取多少，A 保证取剩余堆石头且数目和为 K+1 即可获胜
             M % (K+1) != 0 B 胜，B 取"余数"个，B 保证在剩余堆中取和 A 取数目和为 K+1 即可
        【结论 2】简证
        将 M1 ~ Mn 依次用二进制表示，从最高位向最低位求异或值，若异或值为 0，则往低位继续求
        如果都是0，则XOR(M1, M2,..., Mn) = 0，所以到某一位异或值为 1 时，任意留一个该位为 1
        的 Mi，其他的为 1 的异或为 0。此时的 Mi 将该位改为 0，根据其他值的异或值改变 Mi 低位
        值就可以实现XOR(M1, M2,..., Mi',..., Mn) = 0。
     */
}
