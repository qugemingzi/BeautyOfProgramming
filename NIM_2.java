public class NIM_2 {
    /*
        “拈”游戏
        有 M 块石头和两个玩家 A 和 B，A 先将石头分成若干堆，然后按照 BABA...的顺序轮流
        抽取石头，能将剩下的石头一次取光的玩家获胜。每次取石头时，每个玩家只能从若干堆
        石头中任选一堆，取这一堆石头中任意数目(大于0)个石头。
        请问：玩家A怎样分配和取石头能保证自己有把握取胜？
        analysis:
        我们用 N 表示石头堆数，M 表示总石头数。
        1）N = 1
            只有一堆石头，无论 A 放多少块石头，B 都可以一次性拿完，A 败。
        2）N = 2
            即只有两堆石头，最简单的情况为每堆都只有一个石头(1, 1)，B 先拿，无论怎样 A
            都可以获胜。定义这种在双方理论走法下，A 一定能赢的局面为 “安全局面”。
            M > 2时，考虑(1, 1)为安全局面，那么(1, X)都不是安全局面，因为 B 可以通过
            一步将(1, X)变成(1, 1)。那么(2, 2)呢？它不可以一步变成(1, 1)，除非两步，
            且通过分析知(2, 2)为安全局面，同理(3, 3)...(X, X)都为安全局面。所以我们得到
            初步总结，如果石头总数 M 为偶数，就分为两堆，每堆数目相同，无论 B 怎么取，A
            只需要保证取之后是安全局面(X, X)，则 A 必胜。
        3）M 为奇数呢？
            M = 3，有(2, 1)和(1, 1, 1)两种情况，都是 B 赢。
            M = 5、7...，好像都是 B 赢。
            由此我们又得到一条结论，当摆放方法为(1, 1,..., 1)时，奇数个 1 则 B 赢，偶数
            个 1 则 A 胜。而当摆放方法为(1, 1,..., X)时，B 必赢。因为：
            若奇数个 1，B 只需从(X)堆中取 X-1 个石头；
            若偶数个 1，B 只需从(X)堆中取 X 个石头。
        此时当然还有很多其他的摆法，如何分析呢？关键是找到这一系列变化过程中有没有一个特性
        始终决定着输赢，就得考验一下真功夫了（书里写的），异或(XOR)运算，规则如下：
            XOR(0, 0) = 0
            XOR(0, 1) = 1
            XOR(1, 1) = 0
        统筹来看整个游戏过程，从 N 堆石头(M1, M2,..., Mn)开始斗智斗勇为(0, 0,..., 0)。
        当 M 为偶数时，我们的取胜策略就是将 M 分成相同的两份，这样就可以取胜。
            开始：(M1, M1)         XOR(M1, M1) = 0
            中途：(M1, M2)         XOR(M1, M2) != 0
            A 方：(M2, M2)         XOR(M2, M2) = 0
            ...
            最后：(0, 0)           A 方取胜
        类似的，若 M 为奇数，把石头分为(1, 1,..., 1)奇数堆时，XOR(1, 1,..., 1) != 0，
        此时 B 方取走一堆后，石头堆为偶数堆了，XOR(1, 1,..., 1) = 0，A 败。
        我们推广到 M 为奇数，但每堆石头数目不限于 1 的情况，在观察XOR值的规律。
            开始：(M1, M2,..., Mn)             XOR(M1, M2,..., Mn) = ?
            中途：(M1', M2',..., Mn')          XOR(M1', M2',..., Mn') = ?
            最后：(0, 0,..., 0)                XOR(0, 0,..., 0) = 0
        不幸的是，当有奇数个石头时，无论怎么分堆XOR(M1, M2,..., Mn)总不等于 0，因为必然
        会有奇数堆有奇数个石头（二进制表示最低位为 1），异或的结果最低位为 1。【结论 1】
        再不幸的是，还可以证明，当XOR(M1, M2,..., Mn) != 0时，我们总是只需要改变一个 Mi
        的值，就可以让XOR(M1, M2,..., Mi',..., Mn) = 0。【结论 2】
     */
}
